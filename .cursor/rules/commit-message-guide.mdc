---
description: Assists the user in drafting and validating Git commit messages . This rule acts as a pre-validation helper, providing real-time feedback and suggestions *before* Git hooks enforce the standard. Crucial for ensuring clear, structured, and compliant commit messages.
alwaysApply: false
---
# Commit Message Guide

This rule helps create consistent, professional commit messages following the Conventional Commits specification.

## Conventional Commit Format

```
<type>(<scope>): <description>

[optional body]

[optional footer(s)]
```

## Project Board Integration

### Simple Task ID References
When working on project board tasks, include the task ID for traceability:

```
<type>(<scope>): <description> (#XXX)

# Examples:
chore(tooling): implement husky validation (#001)
fix(deps): move types to devDependencies (#005)
feat(db): add migration system (#011)
```

### ID Format
- **Simple sequential**: [001], [002], [003], etc.
- **Easy reference**: Use #XXX in commits for clean reference
- **Auto-increment**: Always increment from highest existing ID
- **No categorization**: IDs are just for reference, not organization

## Commit Types

### Primary Types
- **feat**: A new feature for the user
- **fix**: A bug fix
- **docs**: Documentation only changes
- **style**: Changes that do not affect the meaning of the code (white-space, formatting, etc.)
- **refactor**: A code change that neither fixes a bug nor adds a feature
- **test**: Adding missing tests or correcting existing tests
- **chore**: Changes to the build process or auxiliary tools and libraries

### Additional Types
- **perf**: A code change that improves performance
- **ci**: Changes to CI configuration files and scripts
- **build**: Changes that affect the build system or external dependencies
- **revert**: Reverts a previous commit

## Scope Guidelines

### Frontend Scopes
- **ui**: User interface components
- **styles**: CSS/styling changes
- **components**: React/Vue components
- **pages**: Page-level changes
- **hooks**: Custom hooks
- **utils**: Frontend utilities

### Backend Scopes
- **api**: API endpoints and routes
- **auth**: Authentication and authorization
- **db**: Database related changes
- **models**: Data models and schemas
- **middleware**: Express middleware
- **services**: Business logic services
- **utils**: Backend utilities

### Infrastructure Scopes
- **docker**: Docker configuration
- **nginx**: Nginx configuration
- **ci**: Continuous integration
- **deploy**: Deployment configuration
- **env**: Environment configuration

### General Scopes
- **deps**: Dependencies
- **config**: Configuration files
- **scripts**: Build/utility scripts
- **tests**: Test files
- **docs**: Documentation

## Message Format Rules

### Subject Line (Required)
- **Length**: Maximum 50 characters (including task ID)
- **Capitalization**: Lowercase for type and scope, sentence case for description
- **Punctuation**: No period at the end
- **Imperative mood**: Use imperative mood ("add" not "added" or "adds")

### Body (Optional)
- **Length**: Wrap at 72 characters
- **Content**: Explain what and why, not how. Keep it concise and focused - avoid exhaustive lists of every change. Summarize the key changes and their purpose.
- **Separation**: Blank line between subject and body

### Footer (Optional)
- **Breaking changes**: Start with "BREAKING CHANGE:"
- **Issues**: Reference issues with "Closes #123" or "Fixes #456"
- **Task reference**: Can include task ID here instead of subject line

## Examples

### Good Commit Messages with Task IDs

```
chore(tooling): implement husky validation (#001)

Add commit message validation using Husky and Commitlint
to ensure consistent conventional commit format across
the project.

- Configure pre-commit hooks for linting
- Set up commit-msg validation
- Document commit conventions
```

```
fix(deps): move types to devDependencies (#005)

Move all @types/* packages from dependencies to devDependencies
to reduce production bundle size and improve security.

Affects both frontend and backend package.json files.
```

```
feat(db): add migration system (#011)

Implement proper database migration system with schema
versioning and rollback capability.

- Replace init scripts with migration runner
- Add versioning for schema changes
- Support rollback operations

BREAKING CHANGE: Database initialization now requires
running migrations instead of init scripts.
```

```
refactor(frontend): migrate to monorepo structure (#008)

Move existing frontend code to packages/frontend directory
and update all import paths and build configurations.

Related to monorepo restructuring initiative.
```

### Alternative Footer Reference

```
chore(tooling): implement husky validation

Add commit message validation using Husky and Commitlint
to ensure consistent conventional commit format.

Task: #001
```

### Good Commit Messages (Original Examples)

```
feat(auth): add JWT token refresh mechanism

Implement automatic token refresh to improve user experience
by reducing the need for manual re-authentication.

Closes #123
```

```
fix(api): resolve user registration validation error

The email validation was incorrectly rejecting valid addresses
containing plus signs. Updated regex pattern to handle RFC 5322
compliant email addresses.
```

```
docs(readme): update installation instructions

Add missing environment variable setup steps and clarify
Docker Compose usage for new contributors.
```

```
refactor(ui): extract reusable button component

Move button styles and logic into shared component to reduce
code duplication across pages.
```

### Bad Commit Messages (Avoid)

```
❌ Fixed stuff
❌ Updated files
❌ WIP
❌ asdf
❌ Fix bug in login (no scope, too vague)
❌ FEAT: ADD NEW FEATURE (wrong capitalization)
❌ feat: Added new feature. (wrong mood, has period)
❌ chore: stuff (#001) (too vague, even with task ID)
❌ docs: consolidate 8 files into one (mentions files not in git)
❌ docs: remove old docs and add new (vague, doesn't reflect actual changes)
```

### Good vs Bad: External Perspective Examples

**Bad** (mentions files that don't exist in git):
```
docs(docs): consolidate multi-client hosting docs

Replace 8 separate documentation files with unified guide.
Files removed: MULTI_CLIENT_FAQ.md, MULTI_DOMAIN_SETUP.md, etc.
```

**Good** (focuses on actual committed files):
```
docs(docs): add multi-client hosting guide

Add comprehensive guide for hosting multiple client
applications with separate databases and subdomains.
```

**Bad** (internal development context):
```
refactor(api): restructure after team discussion

We discussed this in the meeting and decided to move things.
```

**Good** (external reviewer perspective):
```
refactor(api): extract validation logic to middleware

Move request validation from route handlers to dedicated
middleware to improve code reusability and separation of
concerns.
```

### Simple Changes

For simple, straightforward fixes or changes, keep the commit message concise:

```
fix(frontend): delay cursor following until entrance completes
```

```
style(ui): adjust button padding
```

```
refactor(api): extract validation helper
```

Keep it under 50 characters and focus on what changed, not how or why (unless the why is non-obvious).

## Quick Templates

### Feature Addition with Task ID
```
feat(<scope>): add <feature_name> (#XXX)

<description of what the feature does>
<why it was needed>

Closes #<issue_number>
```

### Bug Fix with Task ID
```
fix(<scope>): resolve <bug_description> (#XXX)

<explanation of the bug>
<how it was fixed>

Fixes #<issue_number>
```

### Chore/Tooling with Task ID
```
chore(<scope>): <action> <tool/configuration> (#XXX)

<brief explanation of changes>
<benefits or reasoning>
```

### Documentation with Task ID
```
docs(<scope>): <action> <documentation_item> (#XXX)

<brief explanation of changes>
```

### Refactoring with Task ID
```
refactor(<scope>): <action> <component/functionality> (#XXX)

<reason for refactoring>
<benefits achieved>
```

## Commit Message Perspective

### Balanced Professional Perspective

**Write commit messages with a balanced approach** - describe changes objectively while including relevant context that helps future maintainers understand the codebase.

**Key Principles:**
- **Focus on actual changes**: Only mention files that exist in git (staged files, modified files, deleted files from previous commits)
- **Present imperative tense**: Use "add", "update", "remove" not "added", "updated", "removed"
- **Describe WHAT changed**: Objective description of code changes (what an external reviewer would see)
- **Include WHY when relevant**: Code-relevant reasoning, technical tradeoffs, or important context that helps understand the change
- **Avoid HOW it was developed**: Skip process details, meetings, conversations, or work-in-progress discussions

**What to Include:**
- ✅ Files being added, modified, or deleted (that exist in git)
- ✅ What changed (objective description from diff perspective)
- ✅ Why it changed (technical reasoning, tradeoffs, or code-relevant context)
- ✅ Important architectural decisions or constraints
- ✅ Breaking changes or migration needs

**What to Avoid:**
- ❌ Mentioning files that don't exist in git history or were never committed
- ❌ Internal process details ("we discussed in meeting", "after team review")
- ❌ Work-in-progress details not reflected in actual code
- ❌ Lists of files that were never committed
- ❌ Assuming context without explaining it in the message itself

### Balancing Context vs Clarity

**Include Context When:**
- Technical tradeoff or constraint affects future work
- Architectural decision impacts how code should be used
- Bug fix reasoning helps prevent similar issues
- Performance optimization explains non-obvious changes

**Skip Context When:**
- It's about internal process ("after meeting", "team decided")
- It references conversations or discussions
- It's work-in-progress not reflected in code
- The "why" is obvious from the code change itself

## AI Assistant Instructions

When helping with commit messages:

1. **ALWAYS check git status first**: Before any commit, run `git status` to see what's staged vs modified
2. **Analyze ALL staged changes comprehensively**: 
   - Start with `git diff --cached --stat` to see the scope and size of changes across ALL files
   - Review ALL staged files and their diffs (`git diff --staged`) to understand the full change
   - Identify the main/overall change across all files, not just one file
   - Write commit messages based ONLY on the staged changes visible in git, not from memory, assumptions, or conversations
   - Describe the overall functionality/behavior change, not individual file changes
   - Avoid file-by-file lists - instead describe what the codebase does differently after the change
3. **Verify file existence**: Only mention files that actually exist in the git repository (check with `git ls-files` if needed). Never reference files that were never committed or don't exist in git history.
4. **Stage missing changes logically**: If files are modified but not staged, review them and stage them logically. Consider splitting into multiple commits if changes are unrelated.
5. **Identify task ID**: Check if work relates to a project board task (simple #XXX format)
6. **Suggest appropriate type**: Based on the nature of changes observed in the diffs
7. **Recommend scope**: Based on affected files/functionality from the staged changes
8. **Craft clear subject**: Imperative present tense, under 50 characters (including task ID)
9. **Add concise body**: For complex changes, explain what and why from the code's perspective, not exhaustive lists. Describe the overall change in functionality/behavior, not individual file modifications. Keep it focused and descriptive - describe what an external reviewer would see. Avoid file-by-file bullet lists - instead summarize the main change(s) across all affected files.
10. **Include footers**: For breaking changes or issue references
11. **Validate format**: Ensure compliance with conventional commits
12. **Check spelling**: Ensure professional appearance
13. **Keep it simple**: Use #XXX format for easy reference, not categorization
14. **Balanced perspective**: Describe what changed objectively (like reviewing code), but include relevant technical context about why. Avoid process details but include code-relevant reasoning that helps future maintainers.

### **Pre-Commit Checklist**
Before every commit:
```bash
git status                    # Check what's staged vs modified
git diff --cached --stat      # Review scope of ALL staged changes
git diff --cached             # Review detailed changes across ALL files
git add .                     # Stage any missing changes (if appropriate)
git status                    # Verify everything is staged correctly
git commit                    # Now safe to commit
```

**Key reminder**: When writing the commit message, describe the overall change in functionality/behavior across ALL staged files, not individual file modifications. An external reviewer should understand what the codebase does differently, not which specific files changed.

## Breaking Change Format

For breaking changes, include in footer:
```
BREAKING CHANGE: <description of the breaking change>
<migration instructions if applicable>
```

AND use `!` after type/scope:
```
feat(api)!: change user authentication endpoint (#XXX)

BREAKING CHANGE: The /auth endpoint now requires different parameters.
Update client code to use email instead of username.
```

## Multi-line Message Template with Task ID

```
<type>(<scope>): <short description> (#XXX)

Why this change was needed:
- <reason 1>
- <reason 2>

What was changed:
- <change 1>
- <change 2>

Impact:
- <impact 1>
- <impact 2>

Closes #<issue>



```